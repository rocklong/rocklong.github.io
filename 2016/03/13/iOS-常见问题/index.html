<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>iOS 常见问题 | 海龙 | 博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.iOS 扩展扩展（Extension）是iOS 8中引入的一个非常重要的新特性。扩展让app之间的数据交互成为可能。用户可以在app中使用其他应用提供的功能，而无需离开当前的应用。在iOS 8系统之前，每一个app在物理上都是彼此独立的，app之间不能互访彼此的私有数据。
而在引入扩展之后，其他app可以与扩展进行数据交换。基于安全和性能的考虑，每一个扩展运行在一个单独的进程中，它拥有自己的b">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 常见问题">
<meta property="og:url" content="http://rocklong.github.io/2016/03/13/iOS-常见问题/index.html">
<meta property="og:site_name" content="海龙 | 博客">
<meta property="og:description" content="1.iOS 扩展扩展（Extension）是iOS 8中引入的一个非常重要的新特性。扩展让app之间的数据交互成为可能。用户可以在app中使用其他应用提供的功能，而无需离开当前的应用。在iOS 8系统之前，每一个app在物理上都是彼此独立的，app之间不能互访彼此的私有数据。
而在引入扩展之后，其他app可以与扩展进行数据交换。基于安全和性能的考虑，每一个扩展运行在一个单独的进程中，它拥有自己的b">
<meta property="og:updated_time" content="2016-03-13T10:22:53.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS 常见问题">
<meta name="twitter:description" content="1.iOS 扩展扩展（Extension）是iOS 8中引入的一个非常重要的新特性。扩展让app之间的数据交互成为可能。用户可以在app中使用其他应用提供的功能，而无需离开当前的应用。在iOS 8系统之前，每一个app在物理上都是彼此独立的，app之间不能互访彼此的私有数据。
而在引入扩展之后，其他app可以与扩展进行数据交换。基于安全和性能的考虑，每一个扩展运行在一个单独的进程中，它拥有自己的b">
  
    <link rel="alternative" href="/atom.xml" title="海龙 | 博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/userIcon.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Rock</a></h1>
		</hgroup>

		
		<p class="header-subtitle">水深则流缓，语迟则人贵！</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>About</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Rock</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/images/userIcon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Rock</h1>
			</hgroup>
			
			<p class="header-subtitle">水深则流缓，语迟则人贵！</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-iOS-常见问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/13/iOS-常见问题/" class="article-date">
  	<time datetime="2016-03-13T07:15:25.000Z" itemprop="datePublished">2016-03-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      iOS 常见问题
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-iOS-扩展"><a href="#1-iOS-扩展" class="headerlink" title="1.iOS 扩展"></a>1.iOS 扩展</h3><p>扩展（Extension）是iOS 8中引入的一个非常重要的新特性。扩展让app之间的数据交互成为可能。用户可以在app中使用其他应用提供的功能，而无需离开当前的应用。<br>在iOS 8系统之前，每一个app在物理上都是彼此独立的，app之间不能互访彼此的私有数据。</p>
<p>而在引入扩展之后，其他app可以与扩展进行数据交换。基于安全和性能的考虑，每一个扩展运行在一个单独的进程中，它拥有自己的bundle， bundle后缀名是.appex。扩展bundle必须包含在一个普通应用的bundle的内部。</p>
<p>iOS 8系统有6个支持扩展的系统区域，分别是Today、Share、Action、Photo Editing、Storage Provider、Custom keyboard。支持扩展的系统区域也被称为扩展点。</p>
<h3 id="2-iOS-沙盒机制"><a href="#2-iOS-沙盒机制" class="headerlink" title="2.iOS 沙盒机制"></a>2.iOS 沙盒机制</h3><p>iOS APP可以在自己的沙盒里读写文件，但是，不可以访问其他APP的沙盒。每一个APP都是一个信息孤岛，相互是不可以进行通信的，唯独可以通过URL Scheme。沙盒里面的文件可以是照片、声音文件、文本、属性列表等</p>
<p>沙盒简述：</p>
<p>每一个APP都有一个存储空间，就是沙盒。<br>APP之间不能相互通信。<br>沙盒根目录结构：Documents、Library、temp。</p>
<h4 id="简述一下Documents、Library、tmp的区别："><a href="#简述一下Documents、Library、tmp的区别：" class="headerlink" title="简述一下Documents、Library、tmp的区别："></a>简述一下Documents、Library、tmp的区别：</h4><p><strong>Documents：</strong>用于存储用户数据，iTunes备份和恢复的时候会包括此目录，所以，苹果建议将程序中建立的或在程序中浏览到的文件数据保存在该目录下。</p>
<p><strong>Library：</strong> 包含两个子目录：Caches 和 Preferences。Caches用来存放用户需要缓存的文件。Preferences是APP的偏好设置，可以通过NSUserDefaults来读取和设置。</p>
<p><strong>tmp：</strong> 用于存放临时文件，这个可以放一些当APP退出后不再需要的文件</p>
<h3 id="3-iOS应用是如何实现后台多任务处理（Multitasking）的？"><a href="#3-iOS应用是如何实现后台多任务处理（Multitasking）的？" class="headerlink" title="3.iOS应用是如何实现后台多任务处理（Multitasking）的？"></a>3.iOS应用是如何实现后台多任务处理（Multitasking）的？</h3><p>ios7之后（一个app可以混合调用多种模式）：Background Audio、VoIP、Location Services、Newsstand、Background Task Completion、Background Fetch 、Remote Notification、Background Transfer Service</p>
<p>参考:<a href="https://onevcat.com/2013/08/ios7-background-multitask/" target="_blank" rel="external">iOS7中的多任务</a></p>
<h3 id="4-响应链（Responder-Chain）是什么？它是如何发挥作用的？"><a href="#4-响应链（Responder-Chain）是什么？它是如何发挥作用的？" class="headerlink" title="4.响应链（Responder Chain）是什么？它是如何发挥作用的？"></a>4.响应链（Responder Chain）是什么？它是如何发挥作用的？</h3><p>　产生触摸事件-&gt;UIApplication事件队列-&gt;[UIWindow hitTest:withEvent:]-&gt;返回更合适的view-&gt;[子控件 hitTest:withEvent:]-&gt;返回最合适的view
　</p>
<p>事件的传递和响应的区别：事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件</p>
<p>参考:<a href="http://www.jianshu.com/p/2e074db792ba" target="_blank" rel="external">史上最详细的iOS之事件的传递和响应机制</a></p>
<h3 id="5-IOS中AppDelegate中的生命周期事件的调用条件"><a href="#5-IOS中AppDelegate中的生命周期事件的调用条件" class="headerlink" title="5.IOS中AppDelegate中的生命周期事件的调用条件"></a>5.IOS中AppDelegate中的生命周期事件的调用条件</h3><pre><code>//当应用程序将要进入非活动状态执行，在此期间，应用程序不接受消息或事件，比如来电  
- (void)applicationWillResignActive:(UIApplication *)application  
{  
    NSLog(@&quot;应用程序将要进入非活动状态，即将进入后台&quot;);  
}  

//应用程序已经进入后台运行  
- (void)applicationDidEnterBackground:(UIApplication *)application  
{  
    NSLog(@&quot;如果应用程序支持后台运行，则应用程序已经进入后台运行&quot;);  
}  

//应用程序将要进入活动状态执行  
- (void)applicationWillEnterForeground:(UIApplication *)application  
{  
    NSLog(@&quot;应用程序将要进入活动状态，即将进入前台运行&quot;);  
}  

//应用程序已经进入活动状态  
- (void)applicationDidBecomeActive:(UIApplication *)application  
{  
    NSLog(@&quot;应用程序已进入前台，处于活动状态&quot;);  
}  

//应用程序将要退出，通常用于保存书架喝一些推出前的清理工作，  
- (void)applicationWillTerminate:(UIApplication *)application  
{  
    NSLog(@&quot;应用程序将要退出，通常用于保存书架喝一些推出前的清理工作&quot;);  
}  

//当设备为应用程序分配了太多的内存，操作系统会终止应用程序的运行，在终止前会执行这个方法  
//通常可以在这里进行内存清理工作，防止程序被终止  
-(void)applicationDidReceiveMemoryWarning:(UIApplication *)application  
{  
    NSLog(@&quot;系统内存不足，需要进行清理工作&quot;);  
}  

//当系统时间发生改变时执行  
-(void)applicationSignificantTimeChange:(UIApplication *)application  
{  
    NSLog(@&quot;当系统时间发生改变时执行&quot;);  
}  

//当程序载入后执行  
-(void)applicationDidFinishLaunching:(UIApplication *)application  
{  
    NSLog(@&quot;当程序载入后执行&quot;);  
} 
</code></pre><h3 id="6-iOS四种数据存储"><a href="#6-iOS四种数据存储" class="headerlink" title="6.iOS四种数据存储"></a>6.iOS四种数据存储</h3><pre><code>NSUserDefaults，用于存储配置信息
SQLite，用于存储查询需求较多的数据
CoreData，用于规划应用中的对象
Plist 文件 使用基本对象类型定制的个性化缓存方案
</code></pre><h3 id="7-Cocoa-Touch包含什么？不包含什么？"><a href="#7-Cocoa-Touch包含什么？不包含什么？" class="headerlink" title="7.Cocoa Touch包含什么？不包含什么？"></a>7.Cocoa Touch包含什么？不包含什么？</h3><pre><code>·Cocoa包含Foundation和AppKit框架，可用于开发Mac OS X系统的应用程序。
·Cocoa Touch包含Foundation和UIKit框架，可用于开发iPhone OS系统的应用程序。
·Cocoa是 Mac OS X 的开发环境，Cocoa Touch是 iPhone OS的开发环境。    

Foundation框架实现了NSObjec类（即根类），这个类定义基本对象行为。此外，该框架还实现了用于表示基本类型（例如，字符串和数字）和群体类型（例如，数组和字典）的类，同时也提供一些基本工具，例如用于国际化、对象持久化、文件管理以及XML处理的工具。你还可以使用Foundation框架中的类访问底层系统的实体和服务，例如可以用它来访问端口、线程、锁和进程。Foundation框架以Core Foundation框架为基础，Core Foundation框架提供的是过程化（ANSI C）接口
</code></pre><p><strong>为什么UIKit不是线程安全的？</strong></p>
<p>像UIKit这样大的框架上确保线程安全是一个重大的任务，会带来巨大的成本。改变非原子property为原子property只是所需要改变的一小部分。通常你想要一次改变多个property，然后才能看到更改的结果。对于这一点，Apple不得不暴露一个方法，像CoreData的performBlock:和同步的方法performBlockAndWait:。如果你考虑大多数调用UIKit类是有关配置(configuration)，使他们线程安全更没有意义。<br>然而，即使调用不是关于配置(configuration)来共享内部状态，因此它们不是线程安全的。如果你已经写回到黑暗时代iOS3.2及以前的应用程序，你一定经历过当准备背景图像时使用NSString的drawInRect:withFont:随时崩溃。值得庆幸的是随着iOS4的到来，Apple提供了大部分绘图的方法和类，例如UIColor和UIFont在后台线程中的使用。<br>不幸的是，Apple的文档目前还缺乏有关线程安全的主题。他们建议只在主线程访问，甚至连绘画方法他们都不能保证线程安全。所以阅读iOS的版本说明总是一个好主意。<br>在大多数情况下，UIKit类只应该在程序的主线程使用。无论是从UIResponder派生的类，还是那些涉及以任何方式操作你的应用程序的用户界面</p>
<h3 id="8-iOS开发中用到的设计模式"><a href="#8-iOS开发中用到的设计模式" class="headerlink" title="8.iOS开发中用到的设计模式"></a>8.iOS开发中用到的设计模式</h3><p><strong>一.【代理模式】</strong></p>
<pre><code>使用场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。其实就像是Java中的接口，类可以实现或者不实现协议（接口）中的方法。
优点：低耦合。
使用原则：开闭原则。
实例：TableView的UITableViewDataSource、UITableViewDelegate，通过和protocol的配合，完成代理。    
</code></pre><p><strong>二.【观察者模式】</strong></p>
<pre><code>使用场景：一般是对model层进行观察，Controller和View进行通知的方式，只负责发送消息，不关系谁去接收。一个对象状态改变，通知正在对他进行观察的对象，这些对象根据各自的要求做出响应。
优点：低耦合。
使用原则：接口隔离原则，开闭原则。
实例：KVO键值观察者。通知机制。
</code></pre><p><strong>三.【MVC模式】</strong></p>
<pre><code>使用场景：整个iOS App系统架构就应该按照MVC模式。
优点:层次清晰、易于维护。
实例：model进行数据的存储，View进行视图的显示和响应，controller是model和view之间的桥梁，进行逻辑控制。    
</code></pre><p><strong>四.【单例模式】</strong></p>
<pre><code>使用场景：确保程序运行时只有一个实例，用于进行资源共享控制。
优点：逻辑简单。
原则：单一职责。
实例：
（1）UIAccelerometer类和sharedAccelerometer方法，一般如果方法名中有shared这样的词，就可以认为这是一个可以整个应用程序共享的实例变量，一般是使用了单例。
（2）UIApplication类和sharedApplication方法，我们一般使用该方法来创建全局变量。
（3）NSBundle类和mainBundle方法。
（4）NSFileManager类和defaultManager方法。
（5）NSNotificationCenter类和defaultManager方法。其中NSNotificationCenter也实现了观察者模式。
（6）NSUserDefaults类和defaultUser方法。    
</code></pre><p><strong>五.【策略模式】</strong></p>
<pre><code>使用场景：定义算法族，进行封装，使他们之间可以相互替换。
优点：使算法的变化独立于使用算法的用户。
原则：针对接口编程，而不是针对实现编程。
实例：排序算法，NSArray的sortedArrayUsingSelector    
</code></pre><p><strong>六.【工厂模式</strong></p>
<pre><code>使用场景：工厂方法创建类的实例，多于proxy模式配合，创建可替换代理类。
优点：易于替换，面向抽象编程，application只和抽象工厂的共性抽象类发生调用关系。
原则：依赖倒置原则。
实例：项目部署环境中依赖多个不同类型的数据库时，需要使用工厂配合proxy完成易用性替换。
</code></pre><h3 id="9-iPhone屏幕尺寸、分辨率及适配"><a href="#9-iPhone屏幕尺寸、分辨率及适配" class="headerlink" title="9.iPhone屏幕尺寸、分辨率及适配"></a>9.iPhone屏幕尺寸、分辨率及适配</h3><pre><code>iPhone4(s)：分辨率960*640，高宽比1.5
  iPhone5(s)：分辨率1136*640，高宽比1.775
  iPhone6：分辨率1334*750，高宽比1.779
iPhone6+：分辨率1920*1080，高宽比1.778
</code></pre><p>  参考:<a href="http://blog.csdn.net/phunxm/article/details/42174937" target="_blank" rel="external"> iPhone屏幕尺寸、分辨率及适配</a> </p>
<h3 id="10-UIWindow-介绍：概述、作用、主要属性及方法"><a href="#10-UIWindow-介绍：概述、作用、主要属性及方法" class="headerlink" title="10.UIWindow 介绍：概述、作用、主要属性及方法"></a>10.UIWindow 介绍：概述、作用、主要属性及方法</h3><pre><code> UIWindow 类是 UIView 的子类，用于管理、协调应用中显示的窗口，其两个最重要的职能就是

容器，给 view 提供展示的区域；
将事件(例如：点击事件、拖拉事件等)分发给 view。
而在视图等级中，UIWindow 就是视图等级中的根 view。而每一个 UIWindow 都有一个窗口等级(属性名：windowLevel)，如果应用中同时出现了多个 UIWindow，那么窗口等级高的 UIWindow 将出现在窗口等级低的 UIWindow 的上面；例如：UIAlertView 会显示在一般窗口的上面，那是因为 UIAlertView 的窗口等级比一般窗口的窗口等级高。而一般情况下，一个 iOS 应用都只有一个 UIWindow。

而当你使用 Interface Builder 来创建 UIWindow 时，建议在属性检查器(Attributes inspector)中的载入选项(Launch option)中启用全屏选项，而如果全屏选项没开启的话，你创建的这个 UIWindow 的尺寸大小跟目标设备的尺寸大小是不一致的，这时可能会遇到以下两个问题：

UIWindow 将无法接收到在 UIWindow 边界(bound)外产生的触摸事件(touch events)；
view 默认不会根据 UIWindow 的尺寸进行裁剪，导致 view 超出 UIWindow 的边界。
而在载入选项中启用全屏选项，可避免上述的两个问题。 
</code></pre><p>参考:<a href="http://www.cnblogs.com/ygm900/p/3499521.html" target="_blank" rel="external">UIWindow 介绍：概述、作用、主要属性及方法</a></p>
<h3 id="11-Split-view-Controller-、-Picker-View、Segmented-Control-的用途"><a href="#11-Split-view-Controller-、-Picker-View、Segmented-Control-的用途" class="headerlink" title="11. Split-view Controller 、 Picker View、Segmented Control 的用途"></a>11. Split-view Controller 、 Picker View、Segmented Control 的用途</h3><p> <a href="http://nshipster.cn/uisplitviewcontroller/" target="_blank" rel="external">Split-view Controller</a></p>
<p> <a href="http://www.cnblogs.com/XYQ-208910/p/4767710.html" target="_blank" rel="external">Picker View</a></p>
<p> <a href="http://www.cnblogs.com/minglz/archive/2012/11/24/2783661.html" target="_blank" rel="external">Segmented Control</a></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/03/18/工作交接/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          工作交接
        
      </div>
    </a>
  
  
    <a href="/2016/03/11/iOS-各种底层实现的原理/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">iOS 各种底层实现的原理</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="iOS-常见问题" data-title="iOS 常见问题" data-url="http://rocklong.github.io/2016/03/13/iOS-常见问题/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Rock
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>