<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>海龙 | 博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="iOS Java Angularjs">
<meta property="og:type" content="website">
<meta property="og:title" content="海龙 | 博客">
<meta property="og:url" content="http://rocklong.github.io/index.html">
<meta property="og:site_name" content="海龙 | 博客">
<meta property="og:description" content="iOS Java Angularjs">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="海龙 | 博客">
<meta name="twitter:description" content="iOS Java Angularjs">
  
    <link rel="alternative" href="/atom.xml" title="海龙 | 博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/userIcon.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Rock</a></h1>
		</hgroup>

		
		<p class="header-subtitle">水深则流缓，语迟则人贵！</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>A propos</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Rock</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/images/userIcon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Rock</h1>
			</hgroup>
			
			<p class="header-subtitle">水深则流缓，语迟则人贵！</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-魔方教程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/04/魔方教程/" class="article-date">
  	<time datetime="2016-04-04T03:02:56.000Z" itemprop="datePublished">2016-04-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/04/魔方教程/">魔方教程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="魔方还原"><a href="#魔方还原" class="headerlink" title="魔方还原"></a>魔方还原</h3><blockquote>
<p>周末没事，学习拧魔方感觉还不错，目前能轻轻松松的复原两层，第三层棱角色块的复原有点难度，在复原的过程中需要看公式。需要不断的练习。</p>
<p>魔方参考:<a href="http://jingyan.baidu.com/article/a3f121e408820dfc9052bb1c.html" target="_blank" rel="external">http://jingyan.baidu.com/article/a3f121e408820dfc9052bb1c.html</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-SQLite优化的那些事儿" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/31/SQLite优化的那些事儿/" class="article-date">
  	<time datetime="2016-03-31T07:43:40.000Z" itemprop="datePublished">2016-03-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/31/SQLite优化的那些事儿/">SQLite优化的那些事儿</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-定时压缩SQLite的数据文件"><a href="#1-定时压缩SQLite的数据文件" class="headerlink" title="1.定时压缩SQLite的数据文件"></a>1.定时压缩SQLite的数据文件</h2><blockquote>
<p><strong>产生原因</strong>：数据库实时的插入和删除会使得数据库文件结构混乱，数据库访问速度减慢。当数据库中的表，索引或触发器被撤销，会留下空白磁盘空间。使数据库比需要的大小更大，但能加快INSERT插入速度。</p>
<p>当提交一个从数据库中删除数据的事务时，数据库文件不改变大小。未使用的文件页被标记并在以后的添加操作中再次使用。这种情况下使用VACUUM命令释放删除后留下的空白空间。<br>当开启auto-vacuum，并提交一个从数据库中删除数据的事务时，数据库文件自动收缩，（VACUUM命令在auto-vacuum开启的数据库中不起作用）。数据库会在内部存储一些信息以便支持这一功能，这使得数据库文件比不开启该选项时稍微大一些</p>
<p>解决办法：定期执行 PRAGMA auto_vacuum = 1 和 VACUUM 命令即可</p>
<p>参考链接：<a href="http://blog.csdn.net/cangchen/article/details/44063497" target="_blank" rel="external">http://blog.csdn.net/cangchen/article/details/44063497</a> </p>
<h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3></blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-布隆过滤器-Bloom-Filter-详解实现对账机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/31/布隆过滤器-Bloom-Filter-详解实现对账机制/" class="article-date">
  	<time datetime="2016-03-31T07:27:49.000Z" itemprop="datePublished">2016-03-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/31/布隆过滤器-Bloom-Filter-详解实现对账机制/">布隆过滤器(Bloom Filter)详解实现对账机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="客户端和服务器端对账机制"><a href="#客户端和服务器端对账机制" class="headerlink" title="客户端和服务器端对账机制"></a>客户端和服务器端对账机制</h2><blockquote>
<p>优点: 查询提高了和传输大小变小，适合小数据对账</p>
<p>缺点: 数据量大的情况下会产生一定的误差</p>
<p>参考文档：<a href="http://www.cnblogs.com/haippy/archive/2012/07/13/2590351.html" target="_blank" rel="external">http://www.cnblogs.com/haippy/archive/2012/07/13/2590351.html</a></p>
<p><a href="http://blog.csdn.net/hguisu/article/details/7866173" target="_blank" rel="external">http://blog.csdn.net/hguisu/article/details/7866173</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-聊天表情处理机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/31/聊天表情处理机制/" class="article-date">
  	<time datetime="2016-03-31T01:39:35.000Z" itemprop="datePublished">2016-03-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/31/聊天表情处理机制/">聊天表情处理机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="聊天表情处理机制"><a href="#聊天表情处理机制" class="headerlink" title="聊天表情处理机制"></a>聊天表情处理机制</h2><blockquote>
<p>1.字符串和表情符号做映射。落地发送出去的是字符串的文本消息，在显示的时间进行映射，来显示表情符号。和处理文本消息是一样的。</p>
<p>2.表情文字和表情图片进行映射。最后落地的是图片，不建议这样使用。</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-通讯录相关同步机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/30/通讯录相关同步机制/" class="article-date">
  	<time datetime="2016-03-30T07:05:50.000Z" itemprop="datePublished">2016-03-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/30/通讯录相关同步机制/">通讯录相关同步机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="通讯录模块包含"><a href="#通讯录模块包含" class="headerlink" title="通讯录模块包含"></a>通讯录模块包含</h3><blockquote>
<p>单位通讯录</p>
<p>群组</p>
<p>好友</p>
<p>新朋友</p>
<p>群组</p>
<p>信息服务号（和应用相关）</p>
</blockquote>
<p><strong>单位通讯录</strong></p>
<blockquote>
<ol>
<li><p>涉及数据量大客户端存储效率的问题</p>
</li>
<li><p>本地存储数据安全（数据库加密）</p>
</li>
<li><p>涉及查看人员的权限问题（一些保密信息的问题）</p>
</li>
<li><p>涉及人员部门和公司的变更客户端如何更新（多岗/换岗，一个人多个公司）</p>
</li>
<li><p>用户基本信息更新和用户头像更新（需明确用户头像的url是否是变化）</p>
</li>
<li><p>触发同步的时机(涉及页面的刷新，换终端，从服务器端添加人员)</p>
</li>
</ol>
</blockquote>
<p><strong>好友/新朋友</strong></p>
<blockquote>
<ol>
<li><p>好友列表持久化到本地的时机</p>
</li>
<li><p>好友信息的更新机制</p>
</li>
</ol>
</blockquote>
<p><strong>群组</strong></p>
<blockquote>
<ol>
<li><p>群组列表取增量的时机</p>
</li>
<li><p>单个群组设置的更新机制</p>
</li>
<li><p>群组头像的更新机制 （群组头像合成的时机，删人加人是否要更新群组的头像）</p>
</li>
</ol>
</blockquote>
<p><strong>信息服务号</strong></p>
<blockquote>
<ol>
<li><p>应用列表持久化本地的时机</p>
</li>
<li><p>单个应用设置变更客户端如何更新（应用的菜单信息的变更） </p>
</li>
</ol>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS-RSA的网络安全模型、iOS签名机制总结、登录模块安全机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/30/iOS-RSA的网络安全模型、iOS签名机制总结、登录模块安全机制/" class="article-date">
  	<time datetime="2016-03-30T01:05:21.000Z" itemprop="datePublished">2016-03-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/30/iOS-RSA的网络安全模型、iOS签名机制总结、登录模块安全机制/">iOS RSA的网络安全模型、登录模块安全机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文将针对RSA登录和http请求作讲解，了解 RSA和签名相关的知识</p>
<h2 id="一-登录、登录保持（http请求）"><a href="#一-登录、登录保持（http请求）" class="headerlink" title="一.登录、登录保持（http请求）"></a>一.登录、登录保持（http请求）</h2><h3 id="登录机制"><a href="#登录机制" class="headerlink" title="登录机制"></a>登录机制</h3><blockquote>
<p>登录机制大概可以分为一下三个阶段：</p>
<ol>
<li><p>登录验证：是指客户端提供用户名和密码，向服务器提出登录请求，服务器判断客户端是否可以登录并向客户端确认。</p>
</li>
<li><p>登录保持：是指客户端登录后， 服务器能够分辨出已登录的客户端，并为其持续提供登录权限的服务器。</p>
</li>
<li><p>登出：是指客户端主动退出登录状态。</p>
</li>
</ol>
</blockquote>
<h3 id="第一种网络请求情况（安全级别：II）"><a href="#第一种网络请求情况（安全级别：II）" class="headerlink" title="第一种网络请求情况（安全级别：II）"></a>第一种网络请求情况（安全级别：II）</h3><blockquote>
<p>一般的情况是这个样子的：一但用户登陆成功（单方面MD5加密：服务器加密则客户端不加密，客户端加密则明文传输），服务器为客户端分配sessionID(也可以称为userID),当然有些服务器不但为客户端分配了userID还有可能会为用户提供token了(这个下面会做解释)，然后每次网络请求都将sessionID当做参数传递给服务器</p>
</blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote>
<p>能够保持用户登录状态、区分用户，相对于不返回任何信息的登录要安全了一些.</p>
</blockquote>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote>
<p>如果通过网络嗅探器（例如：青花瓷）可以获取到http链接，这样子服务器返回的sessionID便会被获取到，这样子依然会造成信息泄露，并且还能被伪造请求（浏览器请求）。</p>
</blockquote>
<h3 id="第二种网络请求情况-（安全级别：III）"><a href="#第二种网络请求情况-（安全级别：III）" class="headerlink" title="第二种网络请求情况 （安全级别：III）"></a>第二种网络请求情况 （安全级别：III）</h3><blockquote>
<p>第一种存在明显的安全隐患，但是目前市面上的好多app依然采用第一种方法去实现登录、网络请求，但是对于安全级别较高的app，已经不再适用了。所以在此基础上进行优化—-采用非对称加密（公钥、私钥）。</p>
</blockquote>
<h3 id="登录模型"><a href="#登录模型" class="headerlink" title="登录模型"></a>登录模型</h3><blockquote>
<p>客户端第一次发出登录请求时， 用户密码以明文的方式传输， 一旦被截获， 后果严重。因此密码需要加密，例如可采用RSA非对称加密。具体流程如下：</p>
<p>客户端向服务器第一次发起登录请求（不传输用户名和密码）。<br>服务器利用RSA算法产生一对公钥和私钥。并保留私钥， 将公钥发送给客户端。</p>
<p>客户端收到公钥后， 加密用户密码， 向服务器发起第二次登录请求（传输用户名和加密后的密码）。</p>
<p>服务器利用保留的私钥对密文进行解密，得到真正的密码。</p>
</blockquote>
<h3 id="第三种网络请求情况（安全级别：IIII）"><a href="#第三种网络请求情况（安全级别：IIII）" class="headerlink" title="第三种网络请求情况（安全级别：IIII）"></a>第三种网络请求情况（安全级别：IIII）</h3><blockquote>
<p>再仔细核对上述登录流程， 我们发现服务器判断用户是否登录， 完全依赖于sessionId, 一旦其被截获， 黑客就能够模拟出用户的请求。于是我们需要引入token的概念： 用户登录成功后， 服务器不但为其分配了sessionId, 还分配了token， token是维持登录状态的关键秘密数据。在服务器向客户端发送的token数据，也需要加密。于是一次登录的细节再次扩展。</p>
<p>客户端向服务器第一次发起登录请求（不传输用户名和密码）。<br>服务器利用RSA算法产生一对公钥和私钥。并保留私钥， 将公钥发送给客户端。</p>
<p>客户端收到公钥后， 加密用户密码，向服务器发送用户名和加密后的用户密码； 同时另外产生一对公钥和私钥，自己保留私钥, 向服务器发送公钥； 于是第二次登录请求传输了用户名和加密后的密码以及客户端生成的公钥。</p>
<p>服务器利用保留的私钥对密文进行解密，得到真正的密码。 经过判断， 确定用户可以登录后，生成sessionId和token， 同时利用客户端发送的公钥，对token进行加密。最后将sessionId和加密后的token返还给客户端。</p>
<p>客户端利用自己生成的私钥对token密文解密， 得到真正的token。</p>
</blockquote>
<h3 id="登录保持（也就是http数据请求阶段）"><a href="#登录保持（也就是http数据请求阶段）" class="headerlink" title="登录保持（也就是http数据请求阶段）"></a>登录保持（也就是http数据请求阶段）</h3><blockquote>
<p>引入token后，http请求被获取问题便可得到解决。 服务器将token和其它的一些变量， 利用散列加密算法得到签名后，连同sessionId一并发送给服务器； 服务器取出保存于服务器端的token,利用相同的法则生成校验签名， 如果客户端签名与服务器的校验签名一致， 就认为请求来自登录的客户端。（支付宝一样的机制）</p>
</blockquote>
<pre><code>注：token失效的两种情况：

1. 用户登录出系统
2. token在后台的规定时间内失效（每个token都是有时间效应的）

失效原理：
在服务器端的redis中删除相应key为session的键值对
</code></pre><h3 id="二-散列算法"><a href="#二-散列算法" class="headerlink" title="二.散列算法"></a>二.散列算法</h3><blockquote>
<p>散列是信息的提炼，通常其长度要比信息小得多，且为一个固定长度。加密性强的散列一定是不可逆的，这就意味着通过散列结果，无法推出任何部分的原始信息。任何输入信息的变化，哪怕仅一位，都将导致散列结果的明显变化，这称之为雪崩效应。散列还应该是防冲突的，即找不出具有相同散列结果的两条信息。具有这些特性的散列结果就可以用于验证信息是否被修改。</p>
<p>散列算法可以用来加密token生成签名， 以便token信息不暴露在网络同时还能验证登录的有效性。    </p>
</blockquote>
<h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><pre><code>全写： Message Digest Algorithm MD5（中文名为消息摘要算法第五版）
    输出： 128bit

MD5算法具有以下特点：

1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。
2、容易计算：从原数据计算出MD5值很容易。
3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
4、弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。
5、强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。

缺陷：Md5一度被认为十分靠谱。2004年8月17日的美国加州圣巴巴拉的国际密码学会议（Crypto’2004）上，来自中国山东大学的王小云教授做了破译MD5、HAVAL-128、 MD4和RIPEMD算法的报告，公布了MD系列算法的破解结果。2009年，冯登国、谢涛二人利用差分攻击，将MD5的碰撞算法复杂度从王小云的2^42进一步降低到2^21，极端情况下甚至可以降低至2^10。仅仅2^21的复杂度意味着即便是在2008年的计算机上，也只要几秒便可以找到一对碰撞。Md5已老， 在安全性要求较高的场合，不建议使用。
</code></pre><h3 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h3><pre><code>全名： 安全哈希算法（Secure Hash Algorithm）输出： 160bit
与Md5比较
相同点：因为二者均由MD4导出，SHA-1和MD5彼此很相似。相应的，他们的强度和其他特性也是相
似。不同点：1. 对强行攻击的安全性：最显著和最重要的区别是SHA-1摘要比MD5摘要长32 位。使
用强行技术，产生任何一个报文使其摘要等于给定报摘要的难度对MD5是2^128数量级的操作，而对
SHA-1则是2^160数量级的操作。这样，SHA-1对强行攻击有更大的强度。2. 对密码分析的安全性：
由于MD5的设计，易受密码分析的攻击，SHA-1显得不易受这样的攻击。3. 速度：在相同的硬件上，
SHA-1的运行速度比MD5慢。    
</code></pre><h3 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a>加盐</h3><pre><code>所谓加盐， 就是在原本需要加密的信息基础上，糅入其它内容salt。签名的生成就是一次加盐。
</code></pre><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><pre><code>本系统使用对称加密对用户密码进行加密以及生成token字符串。
</code></pre><h3 id="AuthCode加密"><a href="#AuthCode加密" class="headerlink" title="AuthCode加密"></a>AuthCode加密</h3><pre><code>AuthCode是康盛科技发明的加密方式， 开源产品Discuz的密码是用这个算法进行加密。但是有点遗憾，这个函数所有权属于康盛创想，并不能自由使用的。不知使用是否有风险？？
</code></pre><h3 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h3><pre><code>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称
Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被
多方分析且广为全世界所使用。    
</code></pre><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><pre><code>RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。RSA的安全基于大数分解的难度。其公钥和私钥是一对大素数（100到200位十进制数或更大）的函数。从一个公钥和密文恢复出明文的难度，等价于分解两个大素数之积（这是公认的数学难题）。

算法描述：
（1）选择一对不同的、足够大的素数p，q。
（2）计算n=pq。
（3）计算f(n)=(p-1)(q-1)，同时对p, q严加保密，不让任何人知道。
（4）找一个与f(n)互质的数e（公钥指数），且1（5）计算d（私钥指数），使得de≡1 mod f(n)。这个公式也可以表达为d ≡e-1 mod f(n)注，≡是数论中表示同余的符号。
（6）公钥KU=(e,n)，私钥KR=(d,n)。
（7）加密时，先将明文变换成0至n-1的一个整数M。若明文较长，可先分割成适当的组，然后再进行交换。设密文为C，则加密过程为：
</code></pre><blockquote>
<p>来源： iOS大全</p>
<p> <a href="http://www.jianshu.com/p/2927ca2b3719" target="_blank" rel="external">http://www.jianshu.com/p/2927ca2b3719</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-charles中如何对https抓包" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/29/charles中如何对https抓包/" class="article-date">
  	<time datetime="2016-03-29T07:47:31.000Z" itemprop="datePublished">2016-03-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/29/charles中如何对https抓包/">charles中如何对https抓包</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果不进行下面的设置，https的reqeust和response都是乱码，设置完之后https就可以抓包了。</p>
<h2 id="手机端操作："><a href="#手机端操作：" class="headerlink" title="手机端操作："></a>手机端操作：</h2><blockquote>
<p>下载Charles证书<a href="http://www.charlesproxy.com/ssl.zip" target="_blank" rel="external">http://www.charlesproxy.com/ssl.zip</a>，解压后导入到iOS设备中（将crt文件作为邮件附件发给自己，再在iOS设备中点击附件即可安装；也可上传至百度之类的网盘，通过safari下载安装）</p>
</blockquote>
<h2 id="电脑端操作："><a href="#电脑端操作：" class="headerlink" title="电脑端操作："></a>电脑端操作：</h2><blockquote>
<p>1、在Charles的工具栏上点击设置按钮，选择Proxy Settings…</p>
<p>切换到SSL选项卡，选中Enable SSL Proxying。（别急，选完先别关掉）</p>
<p>2、SSL选项卡的Locations里填写要抓包的域名和端口，点击Add按钮，在弹出的表单中Host填写域名。比如填api.instagram.com，Port(对应自己的域名)填443</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-工作交接" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/18/工作交接/" class="article-date">
  	<time datetime="2016-03-18T02:31:23.000Z" itemprop="datePublished">2016-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/18/工作交接/">工作交接</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="待交接工作"><a href="#待交接工作" class="headerlink" title="待交接工作"></a>待交接工作</h3><ul>
<li>iOS 客户端相关</li>
</ul>
<pre><code>1.通讯录模块 (好友、群组、新朋友、单位通讯录、标签)
2.图片选择组件
3.九宫格和列表切换
4.二维码
5.组织通讯录选人
6.客户端群组类型
7.版本更新
8.发邮件
9.手势密码

10.崩溃日志信息收集

11.笔记模块
</code></pre><p>   交接负责人：1-10:刘威举、刘良局 11:刘良局</p>
<ul>
<li>服务器后台</li>
</ul>
<p>   <strong>1.通讯录后台</strong></p>
<pre><code>（1）单位通讯录后台（本单位、全集团、常用机构）

   相关功能接口：获取本单位信息，获取全集团信息、获取常用机构、添加常用机构、删除常
   用机构、获取增量信息（用于本地）、搜索单个人。

 (2)群组后台

   相关功能接口：获取群组列表信息、获取单个群组信息、群组邀请人、获取群组增量信息、、

   群组删除人、主动退出群组、群组相关设置、群组头像生成机制、初始化群组策略。

 (3)标签后台

  相关功能接口:获取标签增量信息、添加标签和编辑标签、删除标签.

 (4)好友后台

  相关功能接口：邀请好友、通过验证、删除好友、获取单个好友信息、获取好友增量信息（包

  含新朋友增量信息）、初始化好友策略。

（5）信息服务平台后台

   相关功能接口：参考有道云笔记相关文档。暂略。 
</code></pre><p>   交接负责人：1-5: 王晓磊</p>
<p>  <strong>2.应用集成后台</strong></p>
<pre><code>相关功能参考有道云笔记相关文档。暂略
</code></pre><p>   交接负责人:柴志强    </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS-常见问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/13/iOS-常见问题/" class="article-date">
  	<time datetime="2016-03-13T07:15:25.000Z" itemprop="datePublished">2016-03-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/13/iOS-常见问题/">iOS 常见问题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-iOS-扩展"><a href="#1-iOS-扩展" class="headerlink" title="1.iOS 扩展"></a>1.iOS 扩展</h3><p>扩展（Extension）是iOS 8中引入的一个非常重要的新特性。扩展让app之间的数据交互成为可能。用户可以在app中使用其他应用提供的功能，而无需离开当前的应用。<br>在iOS 8系统之前，每一个app在物理上都是彼此独立的，app之间不能互访彼此的私有数据。</p>
<p>而在引入扩展之后，其他app可以与扩展进行数据交换。基于安全和性能的考虑，每一个扩展运行在一个单独的进程中，它拥有自己的bundle， bundle后缀名是.appex。扩展bundle必须包含在一个普通应用的bundle的内部。</p>
<p>iOS 8系统有6个支持扩展的系统区域，分别是Today、Share、Action、Photo Editing、Storage Provider、Custom keyboard。支持扩展的系统区域也被称为扩展点。</p>
<h3 id="2-iOS-沙盒机制"><a href="#2-iOS-沙盒机制" class="headerlink" title="2.iOS 沙盒机制"></a>2.iOS 沙盒机制</h3><p>iOS APP可以在自己的沙盒里读写文件，但是，不可以访问其他APP的沙盒。每一个APP都是一个信息孤岛，相互是不可以进行通信的，唯独可以通过URL Scheme。沙盒里面的文件可以是照片、声音文件、文本、属性列表等</p>
<p>沙盒简述：</p>
<p>每一个APP都有一个存储空间，就是沙盒。<br>APP之间不能相互通信。<br>沙盒根目录结构：Documents、Library、temp。</p>
<h4 id="简述一下Documents、Library、tmp的区别："><a href="#简述一下Documents、Library、tmp的区别：" class="headerlink" title="简述一下Documents、Library、tmp的区别："></a>简述一下Documents、Library、tmp的区别：</h4><p><strong>Documents：</strong>用于存储用户数据，iTunes备份和恢复的时候会包括此目录，所以，苹果建议将程序中建立的或在程序中浏览到的文件数据保存在该目录下。</p>
<p><strong>Library：</strong> 包含两个子目录：Caches 和 Preferences。Caches用来存放用户需要缓存的文件。Preferences是APP的偏好设置，可以通过NSUserDefaults来读取和设置。</p>
<p><strong>tmp：</strong> 用于存放临时文件，这个可以放一些当APP退出后不再需要的文件</p>
<h3 id="3-iOS应用是如何实现后台多任务处理（Multitasking）的？"><a href="#3-iOS应用是如何实现后台多任务处理（Multitasking）的？" class="headerlink" title="3.iOS应用是如何实现后台多任务处理（Multitasking）的？"></a>3.iOS应用是如何实现后台多任务处理（Multitasking）的？</h3><p>ios7之后（一个app可以混合调用多种模式）：Background Audio、VoIP、Location Services、Newsstand、Background Task Completion、Background Fetch 、Remote Notification、Background Transfer Service</p>
<p>参考:<a href="https://onevcat.com/2013/08/ios7-background-multitask/" target="_blank" rel="external">iOS7中的多任务</a></p>
<h3 id="4-响应链（Responder-Chain）是什么？它是如何发挥作用的？"><a href="#4-响应链（Responder-Chain）是什么？它是如何发挥作用的？" class="headerlink" title="4.响应链（Responder Chain）是什么？它是如何发挥作用的？"></a>4.响应链（Responder Chain）是什么？它是如何发挥作用的？</h3><p>　产生触摸事件-&gt;UIApplication事件队列-&gt;[UIWindow hitTest:withEvent:]-&gt;返回更合适的view-&gt;[子控件 hitTest:withEvent:]-&gt;返回最合适的view
　</p>
<p>事件的传递和响应的区别：事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件</p>
<p>参考:<a href="http://www.jianshu.com/p/2e074db792ba" target="_blank" rel="external">史上最详细的iOS之事件的传递和响应机制</a></p>
<h3 id="5-IOS中AppDelegate中的生命周期事件的调用条件"><a href="#5-IOS中AppDelegate中的生命周期事件的调用条件" class="headerlink" title="5.IOS中AppDelegate中的生命周期事件的调用条件"></a>5.IOS中AppDelegate中的生命周期事件的调用条件</h3><pre><code>//当应用程序将要进入非活动状态执行，在此期间，应用程序不接受消息或事件，比如来电  
- (void)applicationWillResignActive:(UIApplication *)application  
{  
    NSLog(@&quot;应用程序将要进入非活动状态，即将进入后台&quot;);  
}  

//应用程序已经进入后台运行  
- (void)applicationDidEnterBackground:(UIApplication *)application  
{  
    NSLog(@&quot;如果应用程序支持后台运行，则应用程序已经进入后台运行&quot;);  
}  

//应用程序将要进入活动状态执行  
- (void)applicationWillEnterForeground:(UIApplication *)application  
{  
    NSLog(@&quot;应用程序将要进入活动状态，即将进入前台运行&quot;);  
}  

//应用程序已经进入活动状态  
- (void)applicationDidBecomeActive:(UIApplication *)application  
{  
    NSLog(@&quot;应用程序已进入前台，处于活动状态&quot;);  
}  

//应用程序将要退出，通常用于保存书架喝一些推出前的清理工作，  
- (void)applicationWillTerminate:(UIApplication *)application  
{  
    NSLog(@&quot;应用程序将要退出，通常用于保存书架喝一些推出前的清理工作&quot;);  
}  

//当设备为应用程序分配了太多的内存，操作系统会终止应用程序的运行，在终止前会执行这个方法  
//通常可以在这里进行内存清理工作，防止程序被终止  
-(void)applicationDidReceiveMemoryWarning:(UIApplication *)application  
{  
    NSLog(@&quot;系统内存不足，需要进行清理工作&quot;);  
}  

//当系统时间发生改变时执行  
-(void)applicationSignificantTimeChange:(UIApplication *)application  
{  
    NSLog(@&quot;当系统时间发生改变时执行&quot;);  
}  

//当程序载入后执行  
-(void)applicationDidFinishLaunching:(UIApplication *)application  
{  
    NSLog(@&quot;当程序载入后执行&quot;);  
} 
</code></pre><h3 id="6-iOS四种数据存储"><a href="#6-iOS四种数据存储" class="headerlink" title="6.iOS四种数据存储"></a>6.iOS四种数据存储</h3><pre><code>NSUserDefaults，用于存储配置信息
SQLite，用于存储查询需求较多的数据
CoreData，用于规划应用中的对象
Plist 文件 使用基本对象类型定制的个性化缓存方案
</code></pre><h3 id="7-Cocoa-Touch包含什么？不包含什么？"><a href="#7-Cocoa-Touch包含什么？不包含什么？" class="headerlink" title="7.Cocoa Touch包含什么？不包含什么？"></a>7.Cocoa Touch包含什么？不包含什么？</h3><pre><code>·Cocoa包含Foundation和AppKit框架，可用于开发Mac OS X系统的应用程序。
·Cocoa Touch包含Foundation和UIKit框架，可用于开发iPhone OS系统的应用程序。
·Cocoa是 Mac OS X 的开发环境，Cocoa Touch是 iPhone OS的开发环境。    

Foundation框架实现了NSObjec类（即根类），这个类定义基本对象行为。此外，该框架还实现了用于表示基本类型（例如，字符串和数字）和群体类型（例如，数组和字典）的类，同时也提供一些基本工具，例如用于国际化、对象持久化、文件管理以及XML处理的工具。你还可以使用Foundation框架中的类访问底层系统的实体和服务，例如可以用它来访问端口、线程、锁和进程。Foundation框架以Core Foundation框架为基础，Core Foundation框架提供的是过程化（ANSI C）接口
</code></pre><p><strong>为什么UIKit不是线程安全的？</strong></p>
<p>像UIKit这样大的框架上确保线程安全是一个重大的任务，会带来巨大的成本。改变非原子property为原子property只是所需要改变的一小部分。通常你想要一次改变多个property，然后才能看到更改的结果。对于这一点，Apple不得不暴露一个方法，像CoreData的performBlock:和同步的方法performBlockAndWait:。如果你考虑大多数调用UIKit类是有关配置(configuration)，使他们线程安全更没有意义。<br>然而，即使调用不是关于配置(configuration)来共享内部状态，因此它们不是线程安全的。如果你已经写回到黑暗时代iOS3.2及以前的应用程序，你一定经历过当准备背景图像时使用NSString的drawInRect:withFont:随时崩溃。值得庆幸的是随着iOS4的到来，Apple提供了大部分绘图的方法和类，例如UIColor和UIFont在后台线程中的使用。<br>不幸的是，Apple的文档目前还缺乏有关线程安全的主题。他们建议只在主线程访问，甚至连绘画方法他们都不能保证线程安全。所以阅读iOS的版本说明总是一个好主意。<br>在大多数情况下，UIKit类只应该在程序的主线程使用。无论是从UIResponder派生的类，还是那些涉及以任何方式操作你的应用程序的用户界面</p>
<h3 id="8-iOS开发中用到的设计模式"><a href="#8-iOS开发中用到的设计模式" class="headerlink" title="8.iOS开发中用到的设计模式"></a>8.iOS开发中用到的设计模式</h3><p><strong>一.【代理模式】</strong></p>
<pre><code>使用场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。其实就像是Java中的接口，类可以实现或者不实现协议（接口）中的方法。
优点：低耦合。
使用原则：开闭原则。
实例：TableView的UITableViewDataSource、UITableViewDelegate，通过和protocol的配合，完成代理。    
</code></pre><p><strong>二.【观察者模式】</strong></p>
<pre><code>使用场景：一般是对model层进行观察，Controller和View进行通知的方式，只负责发送消息，不关系谁去接收。一个对象状态改变，通知正在对他进行观察的对象，这些对象根据各自的要求做出响应。
优点：低耦合。
使用原则：接口隔离原则，开闭原则。
实例：KVO键值观察者。通知机制。
</code></pre><p><strong>三.【MVC模式】</strong></p>
<pre><code>使用场景：整个iOS App系统架构就应该按照MVC模式。
优点:层次清晰、易于维护。
实例：model进行数据的存储，View进行视图的显示和响应，controller是model和view之间的桥梁，进行逻辑控制。    
</code></pre><p><strong>四.【单例模式】</strong></p>
<pre><code>使用场景：确保程序运行时只有一个实例，用于进行资源共享控制。
优点：逻辑简单。
原则：单一职责。
实例：
（1）UIAccelerometer类和sharedAccelerometer方法，一般如果方法名中有shared这样的词，就可以认为这是一个可以整个应用程序共享的实例变量，一般是使用了单例。
（2）UIApplication类和sharedApplication方法，我们一般使用该方法来创建全局变量。
（3）NSBundle类和mainBundle方法。
（4）NSFileManager类和defaultManager方法。
（5）NSNotificationCenter类和defaultManager方法。其中NSNotificationCenter也实现了观察者模式。
（6）NSUserDefaults类和defaultUser方法。    
</code></pre><p><strong>五.【策略模式】</strong></p>
<pre><code>使用场景：定义算法族，进行封装，使他们之间可以相互替换。
优点：使算法的变化独立于使用算法的用户。
原则：针对接口编程，而不是针对实现编程。
实例：排序算法，NSArray的sortedArrayUsingSelector    
</code></pre><p><strong>六.【工厂模式</strong></p>
<pre><code>使用场景：工厂方法创建类的实例，多于proxy模式配合，创建可替换代理类。
优点：易于替换，面向抽象编程，application只和抽象工厂的共性抽象类发生调用关系。
原则：依赖倒置原则。
实例：项目部署环境中依赖多个不同类型的数据库时，需要使用工厂配合proxy完成易用性替换。
</code></pre><h3 id="9-iPhone屏幕尺寸、分辨率及适配"><a href="#9-iPhone屏幕尺寸、分辨率及适配" class="headerlink" title="9.iPhone屏幕尺寸、分辨率及适配"></a>9.iPhone屏幕尺寸、分辨率及适配</h3><pre><code>iPhone4(s)：分辨率960*640，高宽比1.5
  iPhone5(s)：分辨率1136*640，高宽比1.775
  iPhone6：分辨率1334*750，高宽比1.779
iPhone6+：分辨率1920*1080，高宽比1.778
</code></pre><p>  参考:<a href="http://blog.csdn.net/phunxm/article/details/42174937" target="_blank" rel="external"> iPhone屏幕尺寸、分辨率及适配</a> </p>
<h3 id="10-UIWindow-介绍：概述、作用、主要属性及方法"><a href="#10-UIWindow-介绍：概述、作用、主要属性及方法" class="headerlink" title="10.UIWindow 介绍：概述、作用、主要属性及方法"></a>10.UIWindow 介绍：概述、作用、主要属性及方法</h3><pre><code> UIWindow 类是 UIView 的子类，用于管理、协调应用中显示的窗口，其两个最重要的职能就是

容器，给 view 提供展示的区域；
将事件(例如：点击事件、拖拉事件等)分发给 view。
而在视图等级中，UIWindow 就是视图等级中的根 view。而每一个 UIWindow 都有一个窗口等级(属性名：windowLevel)，如果应用中同时出现了多个 UIWindow，那么窗口等级高的 UIWindow 将出现在窗口等级低的 UIWindow 的上面；例如：UIAlertView 会显示在一般窗口的上面，那是因为 UIAlertView 的窗口等级比一般窗口的窗口等级高。而一般情况下，一个 iOS 应用都只有一个 UIWindow。

而当你使用 Interface Builder 来创建 UIWindow 时，建议在属性检查器(Attributes inspector)中的载入选项(Launch option)中启用全屏选项，而如果全屏选项没开启的话，你创建的这个 UIWindow 的尺寸大小跟目标设备的尺寸大小是不一致的，这时可能会遇到以下两个问题：

UIWindow 将无法接收到在 UIWindow 边界(bound)外产生的触摸事件(touch events)；
view 默认不会根据 UIWindow 的尺寸进行裁剪，导致 view 超出 UIWindow 的边界。
而在载入选项中启用全屏选项，可避免上述的两个问题。 
</code></pre><p>参考:<a href="http://www.cnblogs.com/ygm900/p/3499521.html" target="_blank" rel="external">UIWindow 介绍：概述、作用、主要属性及方法</a></p>
<h3 id="11-Split-view-Controller-、-Picker-View、Segmented-Control-的用途"><a href="#11-Split-view-Controller-、-Picker-View、Segmented-Control-的用途" class="headerlink" title="11. Split-view Controller 、 Picker View、Segmented Control 的用途"></a>11. Split-view Controller 、 Picker View、Segmented Control 的用途</h3><p> <a href="http://nshipster.cn/uisplitviewcontroller/" target="_blank" rel="external">Split-view Controller</a></p>
<p> <a href="http://www.cnblogs.com/XYQ-208910/p/4767710.html" target="_blank" rel="external">Picker View</a></p>
<p> <a href="http://www.cnblogs.com/minglz/archive/2012/11/24/2783661.html" target="_blank" rel="external">Segmented Control</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS-各种底层实现的原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/11/iOS-各种底层实现的原理/" class="article-date">
  	<time datetime="2016-03-11T09:58:18.000Z" itemprop="datePublished">2016-03-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/11/iOS-各种底层实现的原理/">iOS 各种底层实现的原理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>KVO 内部实现原理</li>
</ol>
<pre><code> 1.KVO 是基于runtime机制实现的.

2. 当某个类的对象第一次被观察时,系统就会在运行期动态的创建该类的一个派生类

,在这个派生类中重写基类中任何被观察属性的setter方法; 派生类在被重写的setter方法中

实现真正的通知机制 (Person-&gt;NSKVONotifying_Person)
</code></pre><p>2 . __weak 内部原理</p>
<pre><code> (1).从weak 表中获取废弃对象的地址为键值的记录。

（2).将包含在记录中的所有附有__weak 修饰符变量的地址，赋值为nil。

（3).从weak 表中删除该记录。

（4).从引用计数表中删除废弃对象的地址为键值的记录。
</code></pre><p>3.block 的哪些事</p>
<p> 1.Block和函数的相似性：（1）可以保存代码（2）有返回值（3）有形参（4）调用方式一样。</p>
<p> 2.加__block 就可以修改外部变量的值，其本质就是传值（不加）和传址（加）的区别  </p>
<p> 3.Block 分：栈block，全局block，堆block，分别对应</p>
<ul>
<li>_NSConcretStackBlock</li>
<li>_NSConcretGlobalBlock</li>
<li><p>_NSConcretMallocBlock</p>
<p>栈block:</p>
<p>在ARC下会自动添加 autorelease 会自动copy到堆上，有一种场景是不会给自动添加copy的</p>
</li>
</ul>
<pre><code>-(id) getBlockArray {  
        int val = 10;   
        return [NSArray arrayWithObjects:  
    ^{NSLog(@&quot;blk0:%d&quot;,val);},  
    ^{NSLog(@&quot;blk1:%d&quot;,val);}, nil];  
}   
id obj = getBlockArray();  
typedef void (^blk_t)(void);  
blk_t blk = (blk_t){obj objectAtIndex:0};  
blk(); 

正确改法：
-(id) getBlockArray {  
        int val =10;  
        return [NSArray arrayWithObjects:[^{NSLog(@&quot;blk0:%d&quot;,val);} copy],
                 [^{NSLog(@&quot;blk1:%d&quot;,val);} copy],nil];

}  
</code></pre><p>这段代码在最后一行blk()会异常，因为数组中的block是栈上的。因为val是栈上的。解决办法就是调用    copy方法。这种场景，ARC也不会为你添加copy，因为ARC不确定，采取了保守的措施：不添加copy。所以    ARC下也是会异常退出。</p>
<p>  注意：</p>
<ul>
<li>在栈上调用copy那么复制到堆上</li>
<li>全局block调用copy什么也不做</li>
<li><p>在堆上调用block 引用计数增加    </p>
<p>全局block：</p>
<p> 定义在函数外面的block是global类型的<br> 定义在函数内部的block，但是没有捕获任何自动变量，那么它也是全局的  </p>
</li>
</ul>
<p>参考： </p>
<p>  <a href="http://blog.csdn.net/hherima/article/details/38620175" target="_blank" rel="external">block的内存管理如何验证block在栈上还是在堆上</a>     </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Rock
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>